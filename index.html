<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BSSC Task Tracker â€” Cloud (Google Sheets)</title>

<style>
  body{margin:0;background:#000;color:#fff;font-family:Verdana,Arial,sans-serif;}
  header{
    display:flex;justify-content:space-between;align-items:center;
    padding:16px 18px;border-bottom:1px solid #222;background:#050505;
    position:sticky;top:0;z-index:50;
  }
  h1{margin:0;font-size:20px;}
  .sub{opacity:.75;font-size:12px;margin-top:2px;}
  #addTaskBtn{
    background:#1a73e8;color:#fff;border:none;border-radius:10px;
    padding:10px 14px;font-size:13px;font-weight:700;cursor:pointer;
  }
  #addTaskBtn:hover{background:#2b7de9;}
  .wrap{max-width:1200px;margin:auto;padding:18px;}
  .note{
    border:1px solid #2a2a2a;background:#0d0d0d;border-radius:12px;
    padding:12px 14px;margin:0 0 14px;font-size:12px;line-height:1.45;opacity:.92;
  }

  /* ===== Savage Banner ===== */
  #savageZone{display:none;margin:0 0 14px;}
  .savage{
    border:2px solid #7a0000;background:#2b0000;border-radius:12px;
    padding:14px;
  }
  .savage h3{margin:0 0 6px;color:#ffb3b3;font-size:16px;}
  .savage p{margin:6px 0;font-size:13px;line-height:1.4;}
  .savage .meta{opacity:.85;font-size:12px;}
  .savage .actions{margin-top:10px;}
  .savage button{
    background:#000;color:#fff;border:1px solid #555;border-radius:10px;
    padding:7px 10px;margin-right:8px;cursor:pointer;font-size:12px;
  }
  .savage button:hover{border-color:#aaa;}

  /* ===== Board ===== */
  .tier{
    border:1px solid #333;border-radius:14px;padding:14px;margin:0 0 16px;background:#111;
  }
  .tier h2{margin:0 0 10px;font-size:18px;}
  .tier .tierHint{opacity:.75;font-size:12px;margin-bottom:10px;}
  .row{
    display:grid;
    grid-template-columns: 28px 1fr 130px 230px 70px;
    gap:26px;
    align-items:center;
    margin:8px 0;
  }
  input[type="checkbox"]{width:18px;height:18px;cursor:pointer;}
  .taskText{
    font-weight:600;font-size:13px;line-height:1.3;
  }
  .taskText.done{text-decoration:line-through;opacity:.45;}
  .taskText.waiting{opacity:.70;font-style:italic;}

  select, input[type="text"]{
    background:#0f0f0f;color:#fff;border:1px solid #444;border-radius:10px;
    padding:7px 10px;font-size:12px;
  }

  .status-ready{color:#ff4d4d;font-weight:800;}
  .status-waiting{color:#ffd24d;font-weight:800;}
  .status-done{color:#5cff5c;font-weight:800;}

  .btns{display:flex;gap:8px;justify-content:flex-end;}
  .iconBtn{
    background:#000;border:1px solid #555;color:#fff;border-radius:10px;
    padding:7px 10px;cursor:pointer;font-size:12px;
  }
  .iconBtn:hover{border-color:#aaa;}
  .danger:hover{border-color:#ff6b6b;}

  /* ===== Hall of Shame (DONE tasks) ===== */
  .hall{
    border:1px solid #333;border-radius:14px;padding:12px;background:#0b0b0b;
    margin-top:12px;
  }
  .hall h3{margin:0 0 10px;}
  .log{font-size:11px;opacity:.92;border-bottom:1px solid #222;padding:7px 0;}
  .pill{
    display:inline-block;padding:2px 7px;border:1px solid #444;border-radius:999px;
    font-size:10px;margin-right:6px;opacity:.95;
  }

  /* ===== Modal ===== */
  #modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.78);z-index:999;}
  #modalBox{
    width:390px;max-width:92vw;margin:110px auto;background:#111;border:1px solid #444;
    border-radius:14px;padding:16px;
  }
  #modalBox h3{margin:0 0 12px;}
  #modalBox label{display:block;font-size:12px;opacity:.85;margin:8px 0 6px;}
  #modalBox .error{
    display:none;color:#ff6b6b;font-size:12px;margin:0 0 6px;
  }
  #modalActions{display:flex;gap:10px;justify-content:flex-end;margin-top:8px;}
  #modalActions button{
    background:#000;color:#fff;border:1px solid #555;border-radius:10px;
    padding:8px 12px;cursor:pointer;font-size:12px;
  }
  #modalActions button:hover{border-color:#aaa;}

  /* Small screens */
  @media(max-width:900px){
    .row{grid-template-columns: 28px 1fr 120px 1fr 70px;}
  }
  @media(max-width:650px){
    .row{grid-template-columns: 28px 1fr;}
    .row > *:nth-child(3),
    .row > *:nth-child(4),
    .row > *:nth-child(5){grid-column:2;}
    .btns{justify-content:flex-start;}
  }
</style>
</head>

<body>
<header>
  <div>
    <h1>BSSC Task Tracker</h1>
    <div class="sub">Cloud (Google Sheets) â€¢ Works anywhere â€¢ Ready / Waiting / Done â€¢ Accountability enabled</div>
  </div>
  <button id="addTaskBtn">Add Task</button>
</header>

<div class="wrap">

  <div class="note">
    <b>Statuses:</b>
    <span class="status-ready">READY</span> = actionable now â€¢
    <span class="status-waiting">WAITING</span> = blocked (pauses nagging) â€¢
    <span class="status-done">DONE</span> = finished (still visible, can undo)<br><br>
    <b>Nag cadence:</b> Tier 1 daily â€¢ Tier 2 daily â€¢ Tier 3 every other day â€¢ Tier 4 every 2 days â€¢ Tier 5 weekly
  </div>

  <div id="savageZone"></div>

  <div id="board"></div>

  <div class="hall">
    <h3>Hall of Shame (DONE Tasks)</h3>
    <div id="logs"></div>
  </div>
</div>

<!-- Add/Edit Modal -->
<div id="modal">
  <div id="modalBox">
    <h3 id="modalTitle">Add Task</h3>
    <div id="modalError" class="error">Type something. Telepathy isnâ€™t enabled.</div>

    <label for="taskInput">Task</label>
    <input id="taskInput" type="text" placeholder="Enter task hereâ€¦" />

    <label for="tierSelect">Tier</label>
    <select id="tierSelect"></select>

    <label for="statusSelect">Status</label>
    <select id="statusSelect">
      <option value="ready">READY</option>
      <option value="waiting">WAITING</option>
      <option value="done">DONE</option>
    </select>

    <label for="notesInput">Notes (optional)</label>
    <input id="notesInput" type="text" placeholder="Optional notesâ€¦" />

    <div id="modalActions">
      <button id="cancelBtn" type="button">Cancel</button>
      <button id="saveBtn" type="button">Save</button>
    </div>
  </div>
</div>

<script>
/* =========================
   CLOUD BACKEND (LOCKED)
   ========================= */
const API_URL = "https://script.google.com/macros/s/AKfycbyCVOwhCtWJX2X7bQE9dVNKgtVt-TBt8HTioqFf9Xk1EY-XM8joKX9GS5a0gAzvwouZgw/exec";

/* =========================
   CONSTANTS / TIERS
   ========================= */
const DAY_MS = 24*60*60*1000;

const TIERS = [
  { id:"tier1", title:"ðŸ”´ Tier 1 â€” Critical / Must Do First", cadenceDays:1 },
  { id:"tier2", title:"ðŸŸ  Tier 2 â€” High Impact Operations", cadenceDays:1 },
  { id:"tier3", title:"ðŸŸ¡ Tier 3 â€” Revenue & Program Growth", cadenceDays:2 },
  { id:"tier4", title:"ðŸ”µ Tier 4 â€” Brand / Identity", cadenceDays:2 },
  { id:"tier5", title:"ðŸŸ£ Tier 5 â€” Content / Nice-to-Have", cadenceDays:7 },
  { id:"parked",title:"âšª Parked / Deprecated", cadenceDays:null }
];

/* =========================
   SAVAGE MESSAGE ENGINE
   (session-only; tasks persist in cloud)
   ========================= */
const ROAST = {
  tier1: [
    "Tier 1 is still open. Thatâ€™s not a vibe. Thatâ€™s a problem.",
    "Tier 1 overdue. Congratulations, youâ€™ve invented chaos again.",
    "This is critical. Pretending itâ€™s fine does not count as progress.",
    "Tier 1 ignored long enough to qualify as negligence."
  ],
  tier2: [
    "Tier 2 is aging like milk. You gonna do anything or nah?",
    "High-impact stuff doesnâ€™t complete itself. Tragically.",
    "Tier 2 is overdue. Thatâ€™s how good systems become â€˜later problemsâ€™."
  ],
  tier3: [
    "Tier 3 called. Growth is not happening by vibes.",
    "We should be arrested for this level of tomfoolery.",
    "This is not blocked. This is being avoided professionally."
  ],
  tier4: [
    "Tier 4 sitting there like a neglected haircut appointment.",
    "Brand work ignored = redo everything later. Pick your pain.",
    "Tier 4 overdue. This is how you end up with â€˜randomâ€™ branding."
  ],
  tier5: [
    "Tier 5 has been ignored so long itâ€™s basically a historical site.",
    "Tier 5 overdue. This is peak nonsense. Elite procrastination.",
    "Tier 5 is still waiting. Patient little thing, isnâ€™t it?"
  ]
};

function todayKey(){ return new Date().toDateString(); }
function randPick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* =========================
   STATE (CLOUD)
   ========================= */
let tasks = []; // {id,tier,text,status,createdAt,updatedAt,snoozeUntil,completedAt,notes}
let naggedDate = {};   // tierId -> todayKey
let msgHist = {};      // tierId -> [messages used recently]
let lastPickTierId = null;

/* =========================
   API HELPERS
   ========================= */
async function apiGet(){
  const url = API_URL + "?action=get&ts=" + Date.now();
  const r = await fetch(url, { method:"GET" });
  const txt = await r.text();
  try{ return JSON.parse(txt); }
  catch(e){ throw new Error("API did not return JSON. First 200 chars: " + txt.slice(0,200)); }
}

async function apiPost(action, payload){
  const r = await fetch(API_URL, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ action, ...payload })
  });
  const txt = await r.text();
  try{ return JSON.parse(txt); }
  catch(e){ throw new Error("API POST did not return JSON. First 200 chars: " + txt.slice(0,200)); }
}

function rowsToTasks(rows){
  // Expected: [[headers...],[row...],...]
  if(!Array.isArray(rows) || rows.length === 0) return [];
  const header = rows[0].map(h => String(h||"").trim());
  const col = {};
  header.forEach((h,i)=> col[h] = i);

  const get = (row, name) => {
    const idx = col[name];
    return (idx === undefined) ? "" : row[idx];
  };

  const out = [];
  for(let i=1;i<rows.length;i++){
    const row = rows[i];
    if(!row || row.length===0) continue;

    const id = String(get(row,"ID") || "").trim();
    const text = String(get(row,"Task") || "").trim();
    const tier = String(get(row,"Tier") || "tier1").trim();
    const status = String(get(row,"Status") || "ready").trim().toLowerCase();

    if(!id || !text) continue;

    out.push({
      id,
      tier: tier || "tier1",
      text,
      status: ["ready","waiting","done"].includes(status) ? status : "ready",
      createdAt: numOrNow(get(row,"Created")),
      updatedAt: numOrNow(get(row,"Updated")),
      snoozeUntil: numOrZero(get(row,"SnoozeUntil")),
      completedAt: numOrZero(get(row,"Completed")),
      notes: String(get(row,"Notes") || "")
    });
  }
  return out;
}

function taskToRowObj(t){
  // Must match sheet headers exactly
  return {
    ID: t.id,
    Task: t.text,
    Tier: t.tier,
    Status: t.status,
    Created: Number(t.createdAt || Date.now()),
    Updated: Number(t.updatedAt || Date.now()),
    SnoozeUntil: t.snoozeUntil ? Number(t.snoozeUntil) : "",
    Completed: t.completedAt ? Number(t.completedAt) : "",
    Notes: t.notes || ""
  };
}

function numOrNow(v){
  const n = Number(v);
  return isFinite(n) && n>0 ? n : Date.now();
}
function numOrZero(v){
  const n = Number(v);
  return isFinite(n) && n>0 ? n : 0;
}

/* =========================
   UI HELPERS
   ========================= */
function statusClass(status){
  if(status==="ready") return "status-ready";
  if(status==="waiting") return "status-waiting";
  return "status-done";
}
function taskTextClass(status){
  if(status==="done") return "taskText done";
  if(status==="waiting") return "taskText waiting";
  return "taskText";
}

function pickNonRepeatingMessage(tierId){
  const pool = ROAST[tierId] || ["Do the thing."];
  const hist = msgHist[tierId] || [];
  const candidates = pool.filter(m => !hist.includes(m));
  const chosen = candidates.length ? randPick(candidates) : randPick(pool);
  msgHist[tierId] = [chosen].concat(hist).slice(0,6);
  return chosen;
}

function daysSince(ms){
  return Math.floor((Date.now()-ms)/DAY_MS);
}
function tierHasActionableWork(tierId){
  return tasks.some(t => t.tier===tierId && t.status==="ready");
}

/* =========================
   CLOUD LOAD / REFRESH
   ========================= */
async function reloadCloud(){
  const rows = await apiGet(); // array-of-arrays
  tasks = rowsToTasks(rows);
}

/* =========================
   ACCOUNTABILITY ALERT (CLOUD)
   - Looks at oldest UPDATED among READY tasks in each tier
   - Ignores snoozed tasks
   ========================= */
function buildSavageBanner(){
  const zone = document.getElementById("savageZone");
  zone.innerHTML="";
  zone.style.display="none";

  const now = Date.now();
  const today = todayKey();

  const overdue = [];
  TIERS.forEach(t=>{
    if(t.cadenceDays == null) return;
    // Only nag if READY work exists
    const candidates = tasks.filter(x =>
      x.tier===t.id &&
      x.status==="ready" &&
      (!x.snoozeUntil || x.snoozeUntil <= now)
    );
    if(!candidates.length) return;

    // Oldest updated task represents "staleness" for that tier
    candidates.sort((a,b)=>(a.updatedAt||0)-(b.updatedAt||0));
    const oldest = candidates[0];
    const since = daysSince(oldest.updatedAt || now);
    if(since >= t.cadenceDays){
      overdue.push({ tier:t, since });
    }
  });

  if(!overdue.length) return;

  overdue.sort((a,b)=> b.since - a.since);
  const pick = overdue[0];
  const tierId = pick.tier.id;
  lastPickTierId = tierId;

  let msg;
  if(naggedDate[tierId] !== today){
    msg = pickNonRepeatingMessage(tierId);
    naggedDate[tierId] = today;
  } else {
    const hist = msgHist[tierId] || [];
    msg = hist[0] || pickNonRepeatingMessage(tierId);
  }

  zone.style.display="block";
  const card = document.createElement("div");
  card.className="savage";
  card.innerHTML = `
    <h3>Accountability Alert</h3>
    <div class="meta"><b>${pick.tier.title}</b> â€¢ You havenâ€™t moved READY work in <b>${pick.since}</b> day(s).</div>
    <p>${msg}</p>
    <div class="actions">
      <button type="button" data-snooze="1">Snooze 1 day</button>
      <button type="button" data-snooze="3">Snooze 3 days</button>
      <button type="button" data-snooze="7">Snooze 7 days</button>
      <button type="button" data-jump="1">Jump to Tier</button>
    </div>
  `;

  card.querySelectorAll("button[data-snooze]").forEach(btn=>{
    btn.onclick=async ()=>{
      const d = Number(btn.getAttribute("data-snooze"));
      await snoozeTier(tierId, d);
    };
  });
  card.querySelector("button[data-jump]").onclick=()=>{
    const el = document.getElementById(tierId);
    if(el && el.scrollIntoView) el.scrollIntoView({behavior:"smooth"});
  };

  zone.appendChild(card);
}

async function snoozeTier(tierId, days){
  const until = Date.now() + days*DAY_MS;
  const targets = tasks.filter(t => t.tier===tierId && t.status==="ready");
  for(const t of targets){
    t.snoozeUntil = until;
    t.updatedAt = Date.now();
    await apiPost("upsert", { task: taskToRowObj(t) });
  }
  await refresh();
}

/* =========================
   RENDER BOARD
   ========================= */
function render(){
  buildSavageBanner();

  const board = document.getElementById("board");
  board.innerHTML="";

  TIERS.forEach(tier=>{
    const card = document.createElement("div");
    card.className="tier";
    card.id = tier.id;

    const hint = tier.cadenceDays==null
      ? "Parked items never trigger reminders."
      : `Reminder cadence: every ${tier.cadenceDays} day(s) if READY work exists.`;

    card.innerHTML = `<h2>${tier.title}</h2><div class="tierHint">${hint}</div>`;

    const tierTasks = tasks
      .filter(x => x.tier === tier.id)
      .sort((a, b) => {
        const order = { ready: 0, waiting: 1, done: 2 };
        return order[a.status] - order[b.status];
      });

    tierTasks.forEach(task=>{
      const row = document.createElement("div");
      row.className="row";

      // Checkbox toggles DONE / READY
      const cb = document.createElement("input");
      cb.type="checkbox";
      cb.checked = (task.status==="done");
      cb.onchange = async ()=>{
        task.status = cb.checked ? "done" : "ready";
        task.updatedAt = Date.now();
        task.completedAt = (task.status==="done") ? Date.now() : 0;
        await apiPost("upsert", { task: taskToRowObj(task) });
        await refresh();
      };

      // Text
      const text = document.createElement("div");
      text.className = taskTextClass(task.status);
      text.textContent = task.text;

      // Status dropdown
      const status = document.createElement("select");
      ["ready","waiting","done"].forEach(s=>{
        const opt=document.createElement("option");
        opt.value=s;
        opt.textContent=s.toUpperCase();
        if(task.status===s) opt.selected=true;
        status.appendChild(opt);
      });
      status.className = statusClass(task.status);
      status.onchange = async ()=>{
        task.status = status.value;
        task.updatedAt = Date.now();
        task.completedAt = (task.status==="done") ? Date.now() : 0;
        await apiPost("upsert", { task: taskToRowObj(task) });
        await refresh();
      };

      // Move tier dropdown
      const move = document.createElement("select");
      TIERS.forEach(tt=>{
        const opt=document.createElement("option");
        opt.value=tt.id;
        opt.textContent=tt.title;
        if(task.tier===tt.id) opt.selected=true;
        move.appendChild(opt);
      });
      move.onchange = async ()=>{
        task.tier = move.value;
        task.updatedAt = Date.now();
        await apiPost("upsert", { task: taskToRowObj(task) });
        await refresh();
      };

      // Edit / Delete buttons
      const btnWrap = document.createElement("div");
      btnWrap.className="btns";

      const editBtn = document.createElement("button");
      editBtn.className="iconBtn";
      editBtn.type="button";
      editBtn.textContent="âœï¸";
      editBtn.title="Edit task";
      editBtn.onclick=()=>openModal("edit", task);

      const delBtn = document.createElement("button");
      delBtn.className="iconBtn danger";
      delBtn.type="button";
      delBtn.textContent="ðŸ—‘ï¸";
      delBtn.title="Delete task";
      delBtn.onclick=async ()=>{
        const ok = confirm("Delete this task?\n\n" + task.text);
        if(!ok) return;
        await apiPost("delete", { id: task.id });
        await refresh();
      };

      btnWrap.appendChild(editBtn);
      btnWrap.appendChild(delBtn);

      row.appendChild(cb);
      row.appendChild(text);
      row.appendChild(status);
      row.appendChild(move);
      row.appendChild(btnWrap);

      card.appendChild(row);
    });

    board.appendChild(card);
  });

  renderHallOfShame();
}

/* =========================
   HALL OF SHAME = DONE TASKS (cloud)
   ========================= */
function renderHallOfShame(){
  const el = document.getElementById("logs");
  const done = tasks
    .filter(t=>t.status==="done")
    .sort((a,b)=>(b.completedAt||0)-(a.completedAt||0));

  if(!done.length){
    el.innerHTML = `<div class="log">No DONE tasks yet. Suspiciously quiet.</div>`;
    return;
  }

  el.innerHTML = done.map(t=>{
    const when = t.completedAt ? new Date(t.completedAt).toLocaleString() : "â€”";
    return `<div class="log">
      <span class="pill">${when}</span>
      <span class="pill">${t.tier}</span>
      ${escapeHtml(t.text)}
    </div>`;
  }).join("");
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* =========================
   ADD/EDIT MODAL
   ========================= */
const modal = document.getElementById("modal");
const modalTitle = document.getElementById("modalTitle");
const modalError = document.getElementById("modalError");
const taskInput = document.getElementById("taskInput");
const notesInput = document.getElementById("notesInput");
const tierSelect = document.getElementById("tierSelect");
const statusSelect = document.getElementById("statusSelect");
const cancelBtn = document.getElementById("cancelBtn");
const saveBtn = document.getElementById("saveBtn");
const addTaskBtn = document.getElementById("addTaskBtn");

let modalMode = "add"; // add | edit
let editTaskId = null;

function fillTierOptions(){
  tierSelect.innerHTML="";
  TIERS.forEach(t=>{
    const opt=document.createElement("option");
    opt.value=t.id;
    opt.textContent=t.title;
    tierSelect.appendChild(opt);
  });
}
fillTierOptions();

function openModal(mode, task){
  modalMode = mode;
  modalError.style.display="none";

  if(mode==="add"){
    modalTitle.textContent="Add Task";
    editTaskId = null;
    taskInput.value="";
    notesInput.value="";
    tierSelect.value="tier1";
    statusSelect.value="ready";
  } else {
    modalTitle.textContent="Edit Task";
    editTaskId = task.id;
    taskInput.value = task.text;
    notesInput.value = task.notes || "";
    tierSelect.value = task.tier;
    statusSelect.value = task.status;
  }

  modal.style.display="block";
  setTimeout(()=>taskInput.focus(), 50);
}

function closeModal(){
  modal.style.display="none";
}

async function saveModal(){
  const text = (taskInput.value||"").trim();
  if(!text){
    modalError.textContent = "Type something. Telepathy isnâ€™t enabled.";
    modalError.style.display="block";
    taskInput.focus();
    return;
  }

  const now = Date.now();

  if(modalMode==="add"){
    const newTask = {
      id: "t_"+now+"_"+Math.floor(Math.random()*100000),
      tier: tierSelect.value,
      text,
      status: statusSelect.value,
      createdAt: now,
      updatedAt: now,
      snoozeUntil: 0,
      completedAt: (statusSelect.value==="done") ? now : 0,
      notes: (notesInput.value||"").trim()
    };
    await apiPost("upsert", { task: taskToRowObj(newTask) });
  } else {
    const t = tasks.find(x=>x.id===editTaskId);
    if(t){
      t.text = text;
      t.tier = tierSelect.value;
      t.status = statusSelect.value;
      t.notes = (notesInput.value||"").trim();
      t.updatedAt = now;
      t.completedAt = (t.status==="done") ? now : 0;
      await apiPost("upsert", { task: taskToRowObj(t) });
    }
  }

  closeModal();
  await refresh();

  // Scroll to the relevant tier after save
  const dest = document.getElementById(tierSelect.value);
  if(dest && dest.scrollIntoView) dest.scrollIntoView({behavior:"smooth"});
}

addTaskBtn.onclick = ()=>openModal("add");
cancelBtn.onclick = closeModal;
saveBtn.onclick = saveModal;

taskInput.addEventListener("keydown", (e)=>{
  if(e.key==="Enter") saveModal();
  if(e.key==="Escape") closeModal();
});
modal.addEventListener("click", (e)=>{
  if(e.target === modal) closeModal();
});

/* =========================
   BOOT / REFRESH
   ========================= */
async function refresh(){
  try{
    await reloadCloud();
    render();
  } catch(err){
    alert("Cloud load failed.\n\n" + err.message);
    console.error(err);
  }
}

// First load
refresh();

// Re-check banner every 60 seconds (UI only)
setInterval(()=>{ buildSavageBanner(); }, 60000);
</script>
</body>
</html>
